/**
 * @fileoverview Firestore Security Rules for SwiftShop.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for user-related data
 * (profiles, addresses, orders, support tickets) and allows public read access
 * to product and category data.  Administrative access is not defined, so all
 * write operations outside of user-owned data are denied by default.
 *
 * Data Structure:
 * - /categories/{categoryId}: Publicly readable product categories.
 * - /products/{productId}: Publicly readable product details.
 * - /settings/branding:  Publicly readable branding settings.
 * - /users/{userId}: User profiles, accessible only by the owning user.
 * - /users/{userId}/addresses/{addressId}: User's addresses, accessible only by the owning user.
 * - /users/{userId}/orders/{orderId}: User's orders, accessible only by the owning user.
 * - /users/{userId}/orders/{orderId}/orderItems/{orderItemId}: Order items within an order, accessible only by the owning user.
 * - /users/{userId}/supportTickets/{supportTicketId}: User's support tickets, accessible only by the owning user.
 * - /users/{userId}/supportTickets/{supportTicketId}/chatMessages/{chatMessageId}: Chat messages within a support ticket, accessible only by the owning user.
 * - /orders/{orderId}: All orders.  Requires custom admin role for write access, user read access not supported.
 *
 * Key Security Decisions:
 * - No user listing is allowed.
 * - Read-only collections (products, categories) are publicly readable.
 * - Ambiguous relationships (e.g., /orders/{orderId} without clear ownership) default to deny all writes.
 *
 * Denormalization for Authorization:
 *  - All user-owned documents contain a `userId` field that must match the
 *  document ID to prevent unauthorized data access.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Allows public read access to category documents.
     * @path /categories/{categoryId}
     * @allow (get, list)
     * @deny (create, update, delete)
     * @principle Publicly readable data.
     */
    match /categories/{categoryId} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }

    /**
     * @description Allows public read access to product documents.
     * @path /products/{productId}
     * @allow (get, list)
     * @deny (create, update, delete)
     * @principle Publicly readable data.
     */
    match /products/{productId} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }

    /**
     * @description Allows public read access to branding settings.
     * @path /settings/branding
     * @allow (get)
     * @deny (create, update, delete, list)
     * @principle Publicly readable data.
     */
    match /settings/branding {
      allow get: if true;
      allow list: if false;
      allow create, update, delete: if false;
    }

    /**
     * @description Enforces user-ownership for user profile documents.
     * @path /users/{userId}
     * @allow (create) User can create their own profile.
     * @allow (get, update, delete, list) Only the user can access their own profile.
     * @deny Creating a profile with a mismatched user ID.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Enforces user-ownership for address documents.
     * @path /users/{userId}/addresses/{addressId}
     * @allow (create) User can create their own address.  Must validate userId.
     * @allow (get, update, delete, list) Only the user can access their own address.
     * @deny Creating an address with a mismatched user ID.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId}/addresses/{addressId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Enforces user-ownership for order documents.
     * @path /users/{userId}/orders/{orderId}
     * @allow (create) User can create their own order.  Must validate userId.
     * @allow (get, update, delete, list) Only the user can access their own order.
     * @deny Creating an order with a mismatched user ID.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId}/orders/{orderId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Enforces user-ownership for order item documents.
     * @path /users/{userId}/orders/{orderId}/orderItems/{orderItemId}
     * @allow (create) User can create their own order item.  Must validate userId.
     * @allow (get, update, delete, list) Only the user can access their own order item.
     * @deny Creating an order item with a mismatched user ID.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId}/orders/{orderId}/orderItems/{orderItemId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.orderId == orderId;
      allow update: if isExistingOwner(userId) && request.resource.data.orderId == resource.data.orderId;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Enforces user-ownership for support ticket documents.
     * @path /users/{userId}/supportTickets/{supportTicketId}
     * @allow (create) User can create their own support ticket.  Must validate userId.
     * @allow (get, update, delete, list) Only the user can access their own support ticket.
     * @deny Creating a support ticket with a mismatched user ID.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId}/supportTickets/{supportTicketId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Enforces user-ownership for chat message documents within support tickets.
     * @path /users/{userId}/supportTickets/{supportTicketId}/chatMessages/{chatMessageId}
     * @allow (create) User can create their own chat message. Must validate userId.
     * @allow (get, update, delete, list) Only the user can access their own chat message.
     * @deny Creating a chat message with a mismatched user ID or ticket ID.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId}/supportTickets/{supportTicketId}/chatMessages/{chatMessageId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.supportTicketId == supportTicketId;
      allow update: if isExistingOwner(userId) && request.resource.data.supportTicketId == resource.data.supportTicketId;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Restricts access to order documents to authorized users/roles.
     * @path /orders/{orderId}
     * @allow (get)
     * @deny (create, update, delete, list)
     * @principle Requires specific authorization for write operations.
     */
    match /orders/{orderId} {
      allow get: if false; // TODO: Add authorization logic for specific users/roles to read all orders
      allow create, update, delete: if false; // TODO: Add authorization logic for admins to write orders
      allow list: if false;
    }

    // Helper functions
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
    }
  }
}