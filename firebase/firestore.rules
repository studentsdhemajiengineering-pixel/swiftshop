/**
 * @fileoverview Firestore Security Rules for SwiftShop.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for user-related data (profiles, addresses, orders, support tickets).
 * Products and Categories are publicly readable. Branding settings are also publicly readable but require administrative privileges to modify (not implemented).
 *
 * Data Structure:
 * - /categories/{categoryId}: Publicly accessible grocery categories.
 * - /products/{productId}: Publicly accessible product details.
 * - /settings/branding: Public branding settings (logo, hero images).
 * - /users/{userId}: User profiles.
 * - /users/{userId}/addresses/{addressId}: User's addresses.
 * - /users/{userId}/orders/{orderId}: User's orders.
 * - /users/{userId}/orders/{orderId}/orderItems/{orderItemId}: Items within an order.
 * - /users/{userId}/supportTickets/{supportTicketId}: User's support tickets.
 * - /users/{userId}/supportTickets/{supportTicketId}/chatMessages/{chatMessageId}: Chat messages within a support ticket.
 *
 * Key Security Decisions:
 * - User data is strictly controlled by the user's ID.
 * - Listing of user documents is allowed only within the user's own subcollections.
 * - No data validation is enforced beyond ownership checks, to allow for rapid prototyping.
 *
 * Denormalization for Authorization:
 * - User-owned documents (addresses, orders, support tickets) use the userId field to match the parent /users/{userId} path.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Allows public read access to grocery categories.
     * @path /categories/{categoryId}
     * @allow (get, list) - Any user can read category data.
     * @deny (create, update, delete) - No user can create, update, or delete categories through client-side rules.
     * @principle Allows public read access to product categories.
     */
    match /categories/{categoryId} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }

    /**
     * @description Allows public read access to product details.
     * @path /products/{productId}
     * @allow (get, list) - Any user can read product data.
     * @deny (create, update, delete) - No user can create, update, or delete products through client-side rules.
     * @principle Allows public read access to product information.
     */
    match /products/{productId} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }

    /**
     * @description Allows public read access to branding settings.
     * @path /settings/branding
     * @allow (get, list) - Any user can read the branding settings.
     * @deny (create, update, delete) - No user can create, update, or delete branding settings through client-side rules.
     * @principle Allows public access to branding information, restricting modifications.
     */
    match /settings/branding {
      allow get, list: if true;
      allow create, update, delete: if false;
    }

    /**
     * @description Restricts access to user profiles to the owning user.
     * @path /users/{userId}
     * @allow (get, list, update, delete) - The user can read and modify their own profile.
     * @allow (create) - The user can create their own profile if the userId matches their auth UID.
     * @deny (get, list, update, delete) - Other users cannot access or modify this profile.
     * @principle Enforces document ownership for user profiles.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Restricts access to user addresses to the owning user.
     * @path /users/{userId}/addresses/{addressId}
     * @allow (get, list, update, delete) - The user can read and modify their own addresses.
     * @allow (create) - The user can create addresses under their own user ID.
     * @deny (get, list, update, delete) - Other users cannot access or modify these addresses.
     * @principle Enforces document ownership for user addresses.
     */
    match /users/{userId}/addresses/{addressId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Restricts access to user orders to the owning user.
     * @path /users/{userId}/orders/{orderId}
     * @allow (get, list, update, delete) - The user can read and modify their own orders.
     * @allow (create) - The user can create orders under their own user ID.
     * @deny (get, list, update, delete) - Other users cannot access or modify these orders.
     * @principle Enforces document ownership for user orders.
     */
    match /users/{userId}/orders/{orderId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Restricts access to order items to the owning user (via parent order).
     * @path /users/{userId}/orders/{orderId}/orderItems/{orderItemId}
     * @allow (get, list, update, delete) - The user can read and modify their own order items.
     * @allow (create) - The user can create order items under their own order.
     * @deny (get, list, update, delete) - Other users cannot access or modify these order items.
     * @principle Enforces document ownership for order items via the parent order.
     */
    match /users/{userId}/orders/{orderId}/orderItems/{orderItemId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Restricts access to user support tickets to the owning user.
     * @path /users/{userId}/supportTickets/{supportTicketId}
     * @allow (get, list, update, delete) - The user can read and modify their own support tickets.
     * @allow (create) - The user can create support tickets under their own user ID.
     * @deny (get, list, update, delete) - Other users cannot access or modify these support tickets.
     * @principle Enforces document ownership for support tickets.
     */
    match /users/{userId}/supportTickets/{supportTicketId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Restricts access to chat messages to the owning user (via parent support ticket).
     * @path /users/{userId}/supportTickets/{supportTicketId}/chatMessages/{chatMessageId}
     * @allow (get, list, update, delete) - The user can read and modify chat messages in their tickets.
     * @allow (create) - The user can create chat messages under their own support ticket.
     * @deny (get, list, update, delete) - Other users cannot access or modify these chat messages.
     * @principle Enforces document ownership for chat messages via the parent support ticket.
     */
    match /users/{userId}/supportTickets/{supportTicketId}/chatMessages/{chatMessageId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }
     /**
      * @description Allow read access to a single order
      * @path /orders/{orderId}
      * @allow get: if true
      */
     match /orders/{orderId} {
          allow get: if true;
          allow list: if false;
          allow create: if false;
          allow update: if false;
          allow delete: if false;
     }

  }

  // Helper functions
  function isSignedIn() {
    return request.auth != null;
  }

  function isOwner(userId) {
    return isSignedIn() && request.auth.uid == userId;
  }

  function isExistingOwner(userId) {
    return isOwner(userId) && resource != null;
  }
}