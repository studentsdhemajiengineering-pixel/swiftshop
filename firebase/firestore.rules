/**
 * @fileoverview Firestore Security Rules for SwiftShop.
 *
 * Core Philosophy:
 * This ruleset enforces a hybrid security model, balancing public readability with strict ownership and role-based access controls.
 *
 * Data Structure:
 * - `/categories`: Publicly readable list of product categories.
 * - `/products`: Publicly readable list of product details, writeable by authorized users.
 * - `/settings/branding`: Public branding settings, publicly readable and admin writable.
 * - `/users/{userId}`: User profiles, accessible only by the owning user.
 * - `/users/{userId}/addresses/{addressId}`: User-owned addresses.
 * - `/users/{userId}/orders/{orderId}`: User-owned orders.
 * - `/users/{userId}/orders/{orderId}/orderItems/{orderItemId}`: Order items within a user-owned order.
 * - `/users/{userId}/supportTickets/{supportTicketId}`: User-owned support tickets.
 * - `/users/{userId}/supportTickets/{supportTicketId}/chatMessages/{chatMessageId}`: Chat messages within a user-owned support ticket.
 *
 * Key Security Decisions:
 * - Public read access for categories and products to enable browsing.
 * - Strict user-ownership model for profiles, addresses, orders, order items, support tickets, and chat messages.
 * - Write access to `products` collection is open in this prototyping phase, but MUST be secured by ownership or role-based restrictions in production.
 *
 * Denormalization for Authorization:
 *   There is currently no denormalization. In the future, consider adding an `ownerId` or `authorId` field to the `products` collection.
 *
 * Structural Segregation:
 *   Private user data is stored in subcollections under `/users/{userId}` to ensure isolation and prevent accidental public listing.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Allows public read access to product categories.
     * @path /categories/{categoryId}
     * @allow (get, list) Any user can read category data.
     * @deny (create, update, delete) No user can create, update, or delete categories via client.
     * @principle Allows public read access for browsing.
     */
    match /categories/{categoryId} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }

    /**
     * @description Allows public read access to product details.
     * @path /products/{productId}
     * @allow (get, list) Any user can read product data.
     * @deny (create, update, delete) All users can create, update, or delete products.
     * @principle Allows public read access for browsing; write access MUST be secured in production.
     */
    match /products/{productId} {
      allow get, list: if true;
      allow create, update, delete: if true; // TODO: Secure this with role-based or ownership restrictions. This should not be open in the long term
    }

    /**
     * @description Allows public read access to branding settings and restricts writes.
     * @path /settings/branding
     * @allow (get) Any user can read branding settings.
     * @deny (create, update, delete) No user can create, update, or delete the settings.
     * @principle Allows public read access; writes MUST be secured with admin role check.
     */
    match /settings/branding {
      allow get: if true;
      allow create, update, delete: if false; // TODO: Secure this with role-based restrictions.
    }

    /**
     * @description Enforces user-ownership for user profiles.
     * @path /users/{userId}
     * @allow (create) The user can create their own profile if the userId matches their auth UID.
     * @allow (get, update, delete) The user can read, update, and delete their own profile if the userId matches their auth UID.
     * @deny (list) Prevents listing all users.
     * @deny (create, get, update, delete) If the userId does not match the auth UID.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId} {
      allow get, update, delete: if isOwner(userId) && resource != null;
      allow create: if isOwner(userId);
      allow list: if false;
    }

    /**
     * @description Enforces user-ownership for addresses.
     * @path /users/{userId}/addresses/{addressId}
     * @allow (create, get, update, delete, list) The user can manage their own addresses if the userId matches their auth UID.
     * @deny (create, get, update, delete, list) If the userId does not match the auth UID.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId}/addresses/{addressId} {
      allow get, list, update, delete: if isOwner(userId) && resource != null;
      allow create: if isOwner(userId);
    }

    /**
     * @description Enforces user-ownership for orders.
     * @path /users/{userId}/orders/{orderId}
     * @allow (create, get, update, delete, list) The user can manage their own orders if the userId matches their auth UID.
     * @deny (create, get, update, delete, list) If the userId does not match the auth UID.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId}/orders/{orderId} {
      allow get, list, update, delete: if isOwner(userId) && resource != null;
      allow create: if isOwner(userId);
    }

    /**
     * @description Enforces user-ownership for order items.
     * @path /users/{userId}/orders/{orderId}/orderItems/{orderItemId}
     * @allow (create, get, update, delete, list) The user can manage their own order items if the userId matches their auth UID.
     * @deny (create, get, update, delete, list) If the userId does not match the auth UID.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId}/orders/{orderId}/orderItems/{orderItemId} {
      allow get, list, update, delete: if isOwner(userId) && resource != null;
      allow create: if isOwner(userId);
    }

    /**
     * @description Enforces user-ownership for support tickets.
     * @path /users/{userId}/supportTickets/{supportTicketId}
     * @allow (create, get, update, delete, list) The user can manage their own support tickets if the userId matches their auth UID.
     * @deny (create, get, update, delete, list) If the userId does not match the auth UID.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId}/supportTickets/{supportTicketId} {
      allow get, list, update, delete: if isOwner(userId) && resource != null;
      allow create: if isOwner(userId);
    }

    /**
     * @description Enforces user-ownership for chat messages within support tickets.
     * @path /users/{userId}/supportTickets/{supportTicketId}/chatMessages/{chatMessageId}
     * @allow (create, get, update, delete, list) The user can manage their own chat messages if the userId matches their auth UID.
     * @deny (create, get, update, delete, list) If the userId does not match the auth UID.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId}/supportTickets/{supportTicketId}/chatMessages/{chatMessageId} {
      allow get, list, update, delete: if isOwner(userId) && resource != null;
      allow create: if isOwner(userId);
    }

       /**
        * @description Restricts access to Orders, but allows anyone to get the data.
        * @path /orders/{orderId}
        * @allow (get) Any signed in user can read the data.
        * @deny (create, update, delete, list) No user can create, update, or delete orders via client.
        * @principle Allows public read access for browsing; writes MUST be secured with admin role check.
        */
    match /orders/{orderId} {
          allow get: if true;
          allow list, create, update, delete: if false; // TODO: Secure this with role-based restrictions.
        }
  }

  // Helper function to determine if the requesting user is the owner of the document.
  function isOwner(userId) {
    return isSignedIn() && request.auth.uid == userId;
  }

  // Helper function to determine if the user is signed in.
  function isSignedIn() {
    return request.auth != null;
  }
}