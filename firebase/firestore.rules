/**
 * @fileoverview Firestore Security Rules for SwiftShop.
 *
 * Core Philosophy: This ruleset prioritizes user data privacy and enforces
 * strict ownership for user-related data. Public data like categories and
 * products are readable by everyone.
 *
 * Data Structure:
 * - Public data (categories, products) are stored in top-level collections.
 * - User-specific data (profiles, addresses, orders, support tickets) are
 *   nested under /users/{userId}.
 *
 * Key Security Decisions:
 * - Users can only access their own profiles and related data.
 * - Listing of user profiles is disallowed for privacy.
 * - Public data collections (categories, products) are readable by everyone.
 * - The 'branding' document is publicly readable but not writable via the client.
 *
 * Denormalization for Authorization:
 *   To ensure fast and secure rules, data required for authorization (e.g., userId)
 *   should be stored directly within the documents.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Grocery categories: public read, authenticated write
     * @path /categories/{categoryId}
     * @allow (get, list): Any user can read the categories.
     * @allow (create, update, delete): Only authenticated users can modify categories.
     * @deny (create, update, delete): Unauthenticated users cannot modify categories.
     * @principle Public read, authenticated write.
     */
    match /categories/{categoryId} {
      allow get, list: if true;
      allow create, update, delete: if isSignedIn();
    }

    /**
     * @description Products: public read, authenticated write
     * @path /products/{productId}
     * @allow (get, list): Any user can read the products.
     * @allow (create, update, delete): Only authenticated users can modify products.
     * @deny (create, update, delete): Unauthenticated users cannot modify products.
     * @principle Public read, authenticated write.
     */
    match /products/{productId} {
      allow get, list: if true;
      allow create, update, delete: if isSignedIn();
    }

    /**
     * @description Branding settings: public read, no write
     * @path /settings/branding
     * @allow (get, list): Any user can read the branding settings.
     * @deny (create, update, delete): No one can modify the branding settings through the client.
     * @principle Public read, restricted write.
     */
    match /settings/branding {
      allow get, list: if true;
      allow create, update, delete: if false;
    }

    /**
     * @description Restricts access to user profiles to the owning user.
     * @path /users/{userId}
     * @allow (get): Only the user can read their own profile.
     * @allow (create): Only the user can create their own profile.
     * @allow (update): Only the user can update their own profile, and only if the document exists.
     * @allow (delete): Only the user can delete their own profile, and only if the document exists.
     * @deny (get): Another user cannot read this user's profile.
     * @deny (create): Another user cannot create a profile using this user's ID.
     * @principle Enforces document ownership.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Restricts access to user addresses to the owning user.
     * @path /users/{userId}/addresses/{addressId}
     * @allow (get, list, create): Only the user can read, list, and create their own addresses.
     * @allow (update, delete): Only the user can update and delete their own addresses, and only if the document exists.
     * @deny (get, list, create): Another user cannot read, list, or create addresses for this user.
     * @principle Enforces document ownership within a subcollection.
     */
    match /users/{userId}/addresses/{addressId} {
      allow get, list, create: if isOwner(userId);
      allow update, delete: if isExistingOwner(userId);
    }

    /**
     * @description Restricts access to user orders to the owning user.
     * @path /users/{userId}/orders/{orderId}
     * @allow (get, list, create): Only the user can read, list, and create their own orders.
     * @allow (update, delete): Only the user can update and delete their own orders, and only if the document exists.
     * @deny (get, list, create): Another user cannot read, list, or create orders for this user.
     * @principle Enforces document ownership within a subcollection.
     */
    match /users/{userId}/orders/{orderId} {
      allow get, list, create: if isOwner(userId);
      allow update, delete: if isExistingOwner(userId);
    }

    /**
     * @description Restricts access to order items to the owning user.
     * @path /users/{userId}/orders/{orderId}/orderItems/{orderItemId}
     * @allow (get, list, create): Only the user can read, list, and create their own order items.
     * @allow (update, delete): Only the user can update and delete their own order items, and only if the document exists.
     * @deny (get, list, create): Another user cannot read, list, or create order items for this user.
     * @principle Enforces document ownership within a deeply nested subcollection.
     */
    match /users/{userId}/orders/{orderId}/orderItems/{orderItemId} {
      allow get, list, create: if isOwner(userId);
      allow update, delete: if isExistingOwner(userId);
    }

    /**
     * @description Restricts access to user support tickets to the owning user.
     * @path /users/{userId}/supportTickets/{supportTicketId}
     * @allow (get, list, create): Only the user can read, list, and create their own support tickets.
     * @allow (update, delete): Only the user can update and delete their own support tickets, and only if the document exists.
     * @deny (get, list, create): Another user cannot read, list, or create support tickets for this user.
     * @principle Enforces document ownership within a subcollection.
     */
    match /users/{userId}/supportTickets/{supportTicketId} {
      allow get, list, create: if isOwner(userId);
      allow update, delete: if isExistingOwner(userId);
    }

    /**
     * @description Restricts access to chat messages to the owning user.
     * @path /users/{userId}/supportTickets/{supportTicketId}/chatMessages/{chatMessageId}
     * @allow (get, list, create): Only the user can read, list, and create their own chat messages.
     * @allow (update, delete): Only the user can update and delete their own chat messages, and only if the document exists.
     * @deny (get, list, create): Another user cannot read, list, or create chat messages for this user.
     * @principle Enforces document ownership within a deeply nested subcollection.
     */
    match /users/{userId}/supportTickets/{supportTicketId}/chatMessages/{chatMessageId} {
      allow get, list, create: if isOwner(userId);
      allow update, delete: if isExistingOwner(userId);
    }

    /**
     * @description Top-level Orders: allow authenticated users to create, read and update
     * @path /orders/{orderId}
     * @allow (get, list, create, update): Only authenticated users can perform these operations.
     * @deny (delete): No user can delete orders.
     * @principle Authenticated access, no deletion.
     */
    match /orders/{orderId} {
      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create: if isSignedIn();
      allow update: if isSignedIn();
      allow delete: if false;
    }
  }

  /**
   * @description Checks if the user is signed in.
   * @returns {boolean} True if the user is signed in, false otherwise.
   */
  function isSignedIn() {
    return request.auth != null;
  }

  /**
   * @description Checks if the authenticated user is the owner of the resource, based on the userId.
   * @param {string} userId The user ID to compare against the authenticated user's ID.
   * @returns {boolean} True if the user is signed in and their UID matches the provided userId, false otherwise.
   */
  function isOwner(userId) {
    return isSignedIn() && request.auth.uid == userId;
  }

  /**
   * @description Checks if the authenticated user is the owner of an existing resource.
   * @param {string} userId The user ID to compare against the authenticated user's ID.
   * @returns {boolean} True if the user is the owner and the resource exists, false otherwise.
   */
  function isExistingOwner(userId) {
    return isOwner(userId) && resource != null;
  }
}